import { Node as FlowNode, Edge as FlowEdge } from "@xyflow/react";

export interface SupabaseBase {
	id: string;
	project_id: string;
	created_at?: string; // Optional, as they are auto-generated by Supabase
	updated_at?: string; // Optional
}

export interface SupabaseSequenceNode extends SupabaseBase {
	name?: string; // Assuming nodes can have names
	type: "dna" | "rna" | "protein"; // from SequenceType in @/types/Node.ts
	sequence: string;
	metadata?: Record<string, unknown>;
	generator_id?: string; // Foreign key to a generator_nodes table entry
}

export interface SupabaseConstraintNode extends SupabaseBase {
	name: string;
	scoring_function?: string; // Example property
}

export interface SupabaseGeneratorNode extends SupabaseBase {
	name: string;
	hyperparameters?: Record<string, unknown>;
}

export interface SupabaseDBEdge extends SupabaseBase {
	constraint_id: string; // FK to SupabaseConstraintNode.id
	sequence_id: string; // FK to SupabaseSequenceNode.id
}

interface ProjectGraphData {
	constraintNodes: SupabaseConstraintNode[];
	sequenceNodes: SupabaseSequenceNode[];
	generatorNodes: SupabaseGeneratorNode[];
	edges: SupabaseDBEdge[];
}

interface FlowData {
	nodes: FlowNode[];
	edges: FlowEdge[];
}

// This function will convert data fetched from Supabase into React Flow compatible nodes and edges.
export function convertProjectDataToFlow(projectData: ProjectGraphData): FlowData {
	const flowNodes: FlowNode[] = [];
	const flowEdges: FlowEdge[] = [];

	// Create a map for quick lookup of generators if they need to be embedded
	const generatorMap = new Map<string, SupabaseGeneratorNode>();
	projectData.generatorNodes.forEach((gen) => generatorMap.set(gen.id, gen));

	// Convert Constraint Nodes
	projectData.constraintNodes.forEach((dbNode) => {
		flowNodes.push({
			id: dbNode.id,
			type: "constraint", // Registered in BlockEditor.tsx
			position: { x: Math.random() * 400, y: Math.random() * 400 }, // Temporary random position
			data: {
				label: dbNode.name || "Constraint",
				// ... any other data for ConstraintNodeComponent from dbNode
				// e.g. scoring_function: dbNode.scoring_function
			},
		});
	});

	// Convert Sequence Nodes
	projectData.sequenceNodes.forEach((dbNode) => {
		// const generator = dbNode.generator_id ? generatorMap.get(dbNode.generator_id) : undefined;
		flowNodes.push({
			id: dbNode.id,
			type: "sequence", // Registered in BlockEditor.tsx
			position: { x: Math.random() * 400 + 200, y: Math.random() * 400 }, // Temporary random position
			data: {
				label: dbNode.name || "Sequence",
				// sequenceType: dbNode.type,
				// actualSequence: dbNode.sequence,
				// generatorInfo: generator ? { name: generator.name /*, params: generator.hyperparameters*/ } : undefined,
				// Pass necessary data to SequenceNodeComponent
			},
		});
	});

	// Convert Edges
	projectData.edges.forEach((dbEdge) => {
		flowEdges.push({
			id: dbEdge.id, // Or `e-${dbEdge.constraint_id}-${dbEdge.sequence_id}`
			source: dbEdge.constraint_id,
			target: dbEdge.sequence_id,
			// type: 'default', // Or your custom edge type if you define one
			// animated: true, // Optional: if you want animated edges
		});
	});

	return { nodes: flowNodes, edges: flowEdges };
}

// NOTE: The old functions like parseProgramJSON, convertProgramToFlow (old version),
// generateLabels, findAndRemoveNodeFromProgram, etc., have been removed as they
// pertained to the old hierarchical program structure.
// The layouting logic from getLayoutedElements in layout.ts will need to be adapted
// to take these flat nodes and edges if ELK-based layout is still desired.
